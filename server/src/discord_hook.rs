use std::collections::HashMap;
use itertools::Itertools;
use unidecode::unidecode;

use crate::{category_type::CategoryType, db::{create_db_connection, query_discord_report, DiscordRaceResultReport, DiscordTeamRaceResultReport}, event_type::EventType};

fn create_finish_reason_string(reason_out: &String) -> String {
    if reason_out == "Running" {
        return "".to_string();
    }

    if reason_out == "" {
        return " (Unknown out reason)".to_string();
    }

    return format!(" ({})", reason_out);
}

fn create_division_str(division: i32) -> String {
    return match division {
        0..=9 => format!(" (Div {})", division+1),
        10 => " (Rookie)".to_owned(),
        _ => "".to_owned()
    };
}

fn create_points_str(result: &DiscordRaceResultReport) -> Option<String> {
    if result.champ_points == 0 {
        return None;
    }

    return Some(format!("{}{}", result.champ_points, create_division_str(result.division)));
}

fn create_placement_str(result: &DiscordRaceResultReport) -> String {
    let finish_position = result.finish_position_in_class + 1;
    let starting_position = result.starting_position_in_class + 1;
    let emoji = match finish_position {
        1 => " :first_place:",
        2 => " :second_place:",
        3 => " :third_place:",
        _ => ""
    };

    return format!("Start: P{}, Finish: P{}/{}{}{}",
        starting_position,
        finish_position,
        result.entries_in_class,
        emoji,
        create_finish_reason_string(&result.reason_out),
    );
}

fn forced_sign(n: i32) -> String {
    if n >= 0 {
        return format!("+{}", n);
    } else {
        return format!("{}", n);
    };
}

fn create_driver_str(result: &DiscordRaceResultReport) -> String {
    if result.team_name.is_empty() {
        return result.driver_name.clone();
    } else {
        return format!("{} ({})", result.driver_name, result.team_name);
    }
}

fn align_discord_message(prefix: &String, alignment: f32, is_bold: bool) -> usize {
    // Numbers generated by:
    // https://playcode.io/1954753
    let normal_widths: [f32; 128] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.75, 5.566666603088379, 10.149999618530273, 8.949999809265137, 11.266666412353516, 9.800000190734863, 2.8499999046325684, 4.933333396911621, 4.933333396911621, 6.400000095367432, 7.833333492279053, 3.866666555404663, 6.5333333015441895, 3.866666555404663, 7.0, 9.350000381469727, 5.699999809265137, 8.300000190734863, 8.733333587646484, 8.899999618530273, 8.583333015441895, 8.566666603088379, 7.333333492279053, 8.449999809265137, 8.566666603088379, 3.866666555404663, 3.866666555404663, 7.833333492279053, 7.833333492279053, 7.833333492279053, 7.633333206176758, 14.483333587646484, 10.300000190734863, 9.800000190734863, 10.183333396911621, 10.533333778381348, 8.966666221618652, 8.716666221618652, 10.716666221618652, 10.716666221618652, 3.866666555404663, 8.199999809265137, 9.683333396911621, 8.899999618530273, 13.399999618530273, 10.899999618530273, 10.949999809265137, 9.716666221618652, 10.949999809265137, 9.966666221618652, 8.899999618530273, 8.516666412353516, 10.683333396911621, 9.633333206176758, 13.050000190734863, 9.399999618530273, 9.433333396911621, 8.816666603088379, 4.9666666984558105, 7.0, 4.9666666984558105, 7.199999809265137, 8.133333206176758, 4.233333110809326, 8.149999618530273, 8.850000381469727, 8.066666603088379, 8.850000381469727, 8.116666793823242, 5.400000095367432, 8.050000190734863, 8.600000381469727, 3.6500000953674316, 3.6500000953674316, 7.800000190734863, 4.050000190734863, 13.0, 8.449999809265137, 8.483333587646484, 8.850000381469727, 8.850000381469727, 6.0333333015441895, 7.233333110809326, 6.133333206176758, 8.449999809265137, 7.550000190734863, 11.233333587646484, 7.333333492279053, 7.516666889190674, 7.0, 5.550000190734863, 3.8333332538604736, 5.550000190734863, 7.833333492279053, 0.0];
    let bold_widths: [f32; 128] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 3.5166666507720947, 4.699999809265137, 7.133333206176758, 11.033333778381348, 9.533333778381348, 12.100000381469727, 10.25, 3.616666555404663, 5.633333206176758, 5.633333206176758, 6.599999904632568, 7.833333492279053, 4.449999809265137, 6.7166666984558105, 4.133333206176758, 7.150000095367432, 9.600000381469727, 6.650000095367432, 9.0, 9.133333206176758, 9.383333206176758, 9.133333206176758, 9.050000190734863, 8.100000381469727, 9.083333015441895, 9.050000190734863, 4.133333206176758, 4.449999809265137, 7.833333492279053, 7.833333492279053, 7.833333492279053, 8.483333587646484, 14.600000381469727, 11.199999809265137, 9.966666221618652, 10.449999809265137, 10.899999618530273, 9.416666984558105, 9.066666603088379, 11.283333778381348, 11.266666412353516, 4.583333492279053, 8.866666793823242, 10.600000381469727, 9.116666793823242, 14.050000190734863, 11.649999618530273, 11.399999618530273, 10.199999809265137, 11.399999618530273, 10.5, 9.399999618530273, 9.699999809265137, 11.333333015441895, 10.783333778381348, 13.916666984558105, 10.800000190734863, 10.116666793823242, 9.399999618530273, 5.583333492279053, 7.150000095367432, 5.583333492279053, 7.833333492279053, 8.316666603088379, 4.816666603088379, 8.433333396911621, 8.949999809265137, 8.166666984558105, 8.949999809265137, 8.5, 5.933333396911621, 8.316666603088379, 8.933333396911621, 4.199999809265137, 4.199999809265137, 8.416666984558105, 4.866666793823242, 13.149999618530273, 8.800000190734863, 8.800000190734863, 8.949999809265137, 8.949999809265137, 6.5, 7.2833333015441895, 6.199999809265137, 8.800000190734863, 8.066666603088379, 12.066666603088379, 8.166666984558105, 7.933333396911621, 7.433333396911621, 6.233333110809326, 4.0, 6.233333110809326, 7.833333492279053, 0.0];

    let widths = if is_bold { &bold_widths } else { &normal_widths };

    // remove accents and stuff
    let decoded_prefix = unidecode(prefix);

    let mut width = 0.0;
    for ch in decoded_prefix.chars() {
        if is_bold {
            width += widths[ch as usize];
        } else {
            width += widths[ch as usize];
        }
    }

    let leftover_space = alignment - width;

    if leftover_space <= 0.0 {
        return 0;
    }

    let space_width = normal_widths[' ' as usize];
    let spaces_required = (leftover_space / space_width).round() as usize;

    return spaces_required;
}

fn create_spaces(n: usize) -> String {
    return std::iter::repeat(' ').take(n).collect::<String>();
}

fn create_single_line_driver_str(result: &DiscordRaceResultReport) -> String {
    let incident_str = create_incident_str(result);
    let irating_str = create_irating_str(result);

    let spaces_required = align_discord_message(&result.driver_name, 170.0, false);

    let mut result = format!("• {}{}", result.driver_name, create_spaces(spaces_required));
    if let Some(irating_str) = irating_str {
        if let Some(incident_str) = incident_str {
            result.push_str(format!("**IRating:** {} | **CPI:** {}", irating_str, incident_str).as_str());
        }
    }
    return result;
}

fn create_irating_str(result: &DiscordRaceResultReport) -> Option<String> {
    if result.event_type != EventType::Race {
        return None;
    }

    let irating_gain = result.newi_rating - result.oldi_rating;
    return Some(format!("{} ({})", result.newi_rating, forced_sign(irating_gain)));
}

fn create_incident_str(result: &DiscordRaceResultReport) -> Option<String> {
    if result.event_type != EventType::Race {
        return None;
    }

    let cpi_str = if result.incidents == 0 {
        "∞".to_owned()
    } else {
        let corners_complete = result.corners_per_lap * result.laps_complete;
        format!("{:.1}", (corners_complete as f32) / (result.incidents as f32))
    };
    return Some(format!("{} ({}x)", cpi_str, result.incidents));
}

fn create_track_str(result: &DiscordRaceResultReport) -> String {
    if result.config_name.is_empty() {
        return result.track_name.clone();
    } else {
        return format!("{} - {}", result.track_name, result.config_name);
    }
}

fn create_car_str(result: &DiscordRaceResultReport) -> String {
    if result.car_class_name.is_empty() {
        return result.car_name.clone();
    } else {
        return format!("{} ({})", result.car_name, result.car_class_name);
    }
}

fn create_series_str(result: &DiscordRaceResultReport) -> String {
    let session_name = if result.session_name.is_empty() {
        &result.series_name
    } else {
        &result.session_name
    };

    return format!("{} ({})", session_name, result.license_category_id.to_nice_string());
}

fn create_iracing_result_url(subsession_id: i64) -> String {
    return format!(
        "https://members-ng.iracing.com/racing/results-stats/results?subsessionid={}",
        subsession_id
    );
}

fn create_link_line_str(team_name: &String, result: &DiscordRaceResultReport) -> String {
    let ir_history_category_str = match result.license_category_id {
        CategoryType::Road | CategoryType::FormulaCar | CategoryType::SportsCar => "road",
        CategoryType::Oval => "oval",
        CategoryType::DirtRoad => "dirt-road",
        CategoryType::DirtOval => "dirt-oval",
    };

    let encoded_team_name = urlencoding::encode(team_name.as_str());
    let encoded_driver_name = urlencoding::encode(result.driver_name.as_str());

    let session_list_url = format!(
        "https://r0mai.io/iracing-stats?team={}&type=session-list&selected={}",
        encoded_team_name,
        encoded_driver_name
    );

    let irating_history_link = format!(
        "https://r0mai.io/iracing-stats?team={}&selected={}&type=irating-history&category={}",
        encoded_team_name,
        encoded_driver_name,
        ir_history_category_str
    );

    let iracing_url = create_iracing_result_url(result.subsession_id);

    return format!("[IRacing Result]({}) | [Latest Results]({}) | [IRating History]({})",
        iracing_url,
        session_list_url,
        irating_history_link
    );
}

fn group_by_pred<T, P>(v: &Vec<T>, pred: P) -> Vec<Vec<T>>
where
    P: Fn(&T, &T) -> bool,
    T: Clone
{
    let mut result = Vec::new();

    if v.is_empty() {
        return result;
    }

    let mut current_group = vec![v[0].clone()];

    for i in 1..v.len() {
        if pred(&v[i-1], &v[i]) {
            current_group.push(v[i].clone());
        } else {
            result.push(current_group);
            current_group = vec![v[i].clone()];
        }
    }

    result.push(current_group);

    return result;
}

fn create_result_message_strings(team_name: &String, reports: &Vec<DiscordRaceResultReport>) -> Vec<String> {
    let mut messages = Vec::new();

    let groups = group_by_pred(reports, |a, b| {
        if a.subsession_id != b.subsession_id {
            return false;
        }

        if a.team_id != b.team_id || a.team_id == -1 {
            return false;
        }

        return true;
    });

    for group in groups {
        let mut lines = Vec::new();

        let link_line_str = create_link_line_str(team_name, &group[0]);

        let placement_str = create_placement_str(&group[0]);
        let track_str = create_track_str(&group[0]);
        let car_str = create_car_str(&group[0]);
        let series_str = create_series_str(&group[0]);
        let incident_str = create_incident_str(&group[0]);
        let irating_str = create_irating_str(&group[0]);
        let points_str = create_points_str(&group[0]);

        let is_team = group.len() > 1;

        if !is_team {
            let driver_str = create_driver_str(&group[0]);

            lines.push(format!("**Driver:**      {}", driver_str));
            lines.push(format!("**Position:**  {}", placement_str));
            if let Some(points_str) = &points_str {
                lines.push(format!("**Points:**     {}", points_str));
            }
        }

        lines.push(format!("**Series:**      {}", series_str));
        lines.push(format!("**Track:**       {}", track_str));
        lines.push(format!("**Car:**           {}", car_str));
        lines.push(format!("**SoF:**          {}", group[0].car_class_sof));

        if is_team {
            lines.push(format!("**Position:**  {}", placement_str));
            if let Some(points_str) = &points_str {
                lines.push(format!("**Points:**     {}", points_str));
            }
            lines.push(format!("**Team:**        {}", group[0].team_name));
            for item in group {
                lines.push(format!("  {}", create_single_line_driver_str(&item)));
            }
        }

        if !is_team {
            if let Some(irating_str) = irating_str {
                lines.push(format!("**IRating:**    {}", irating_str));
            }
            if let Some(incident_str) = incident_str {
                lines.push(format!("**CPI:**           {}", incident_str));
            }
        }

        messages.push(format!(":checkered_flag:\n{}\n\n{}",
            lines.join("\n"),
            link_line_str
        ));
    }

    return messages;
}

fn create_result_message_string(team_name: &String, result: &DiscordRaceResultReport) -> String {
    let link_line_str = create_link_line_str(team_name, result);
    let driver_str = create_driver_str(result);
    let incident_str = create_incident_str(result);
    let irating_str = create_irating_str(result);
    let placement_str = create_placement_str(result);
    let track_str = create_track_str(result);
    let car_str = create_car_str(result);
    let series_str = create_series_str(result);
    let points_str = create_points_str(result);

    let mut lines = Vec::new();
    lines.push(format!("**Driver:**      {}", driver_str));
    lines.push(format!("**Position:**  {}", placement_str));
    lines.push(format!("**Series:**      {}", series_str));
    lines.push(format!("**Car:**           {}", car_str));
    lines.push(format!("**Track:**       {}", track_str));
    lines.push(format!("**SoF:**           {}", result.car_class_sof));
    if let Some(irating_str) = irating_str {
        lines.push(format!("**IRating:**    {}", irating_str));
    }
    if let Some(incident_str) = incident_str {
        lines.push(format!("**CPI:**           {}", incident_str));
    }

    return format!(":checkered_flag:\n{}\n\n{}",
        lines.join("\n"),
        link_line_str
    );
}

fn create_team_report_message_strings(reports: &Vec<DiscordTeamRaceResultReport>) -> Vec<String> {
    let mut messages = Vec::new();
    for (key, chunk) in &reports.into_iter().chunk_by(|report| (report.subsession_id, report.team_id, report.team_name.clone())) {
        let (subsession_id, _team_id, team_name) = key;

        let mut drivers = Vec::new();
        let iracing_url = create_iracing_result_url(subsession_id);

        for report in chunk {
            drivers.push(report.driver_name.clone());
        }

        let drivers_str = drivers.join(", ");

        messages.push(format!("**{}** ({})\n{}", team_name, drivers_str, iracing_url));
    }
    return messages;
}

pub async fn send_discord_update(subsession_ids: Vec<i64>, dry: bool) {
    let connection = create_db_connection();
    let report = query_discord_report(&connection, subsession_ids);

    // TODO iracing_client also has a request::Client. maybe we should have only one
    let client = reqwest::Client::new();

    for team in &report.individual_reports {
        for message in create_result_message_strings(&team.site_team_name, &team.results) {
            send_discord_message(&client, &team.hook_url, &message, dry).await;
        }
    }

    for team in &report.team_reports {
        for message in create_team_report_message_strings(&team.results) {
            send_discord_message(&client, &team.hook_url, &message, dry).await;
        }
    }
}

pub async fn send_discord_message(client: &reqwest::Client, hook_url: &String, msg: &String, dry: bool) {
    if dry {
        println!("{}\n->\n{}", msg, hook_url);
    } else {
        let mut body = HashMap::new();
        body.insert("content", msg);

        let response = client.post(hook_url)
            .json(&body)
            .send()
            .await.unwrap();

        println!("Sending Discord message ({}):\n{}\n->\n{}", response.status().as_u16(), msg, hook_url);
    }
}